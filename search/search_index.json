{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem1 Investigating the Range as a Function of the Angle of Projection 1. Introduction Projectile motion is a fundamental concept in physics, describing the motion of an object launched into the air under the influence of gravity. This study explores how the range of a projectile depends on its angle of projection, analyzing the governing equations and simulating various scenarios to derive insights into its behavior. Understanding these principles has practical applications in fields such as sports, engineering, and aerospace 2. Motivation Projectile motion is not only a fundamental topic in physics but also an essential component in real-world applications. From sports science to military engineering, the ability to predict and manipulate projectile trajectories is crucial. Analyzing the range as a function of the launch angle offers an intuitive yet mathematically rich problem that encapsulates both linear and quadratic relationships. Furthermore, varying initial conditions introduces a wide spectrum of solutions that enhance our understanding of motion in a gravitational field. 3. Theoretical Foundation 3.1 Governing Equations The motion of a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) is governed by Newton\u2019s laws of motion. We decompose the velocity into horizontal and vertical components: \\[ v_{0x} = v_0 \\cos \\theta \\] \\[ v_{0y} = v_0 \\sin \\theta \\] The horizontal and vertical motions are analyzed separately: Horizontal Motion: \\[ x = v_{0x} t = v_0 \\cos \\theta \\cdot t \\] Since there is no acceleration in the horizontal direction (assuming no air resistance), motion remains uniform. Show Python Code import matplotlib.pyplot as plt import numpy as np # Initial parameters v0 = 20 # initial velocity (m/s) theta_deg = 45 # launch angle (degrees) theta_rad = np.radians(theta_deg) # Time array t = np.linspace(0, 3.2, 100) # Horizontal velocity component v0x = v0 * np.cos(theta_rad) # Horizontal position x = v0x * t # Plotting plt.figure(figsize=(8, 4)) plt.plot(t, x, color='orange', linewidth=2) plt.title(\"Horizontal Motion: x(t) = v\u2080\u00b7cos(\u03b8)\u00b7t\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Horizontal Position x (m)\") plt.grid(True) plt.tight_layout() plt.savefig(\"grafik_yatay.png\") plt.show() The graph shows the horizontal position increasing linearly over time, indicating constant velocity with no horizontal acceleration. Vertical Motion: The vertical motion is influenced by gravity \\( g \\) , with acceleration \\( -g \\) : \\[ y = v_{0y} t - \\frac{1}{2} g t^2 \\] The time of flight \\( T \\) can be determined by setting \\( y = 0 \\) (assuming launch and landing occur at the same height): \\[ T = \\frac{2 v_0 \\sin \\theta}{g} \\] Show Python Code import matplotlib.pyplot as plt import numpy as np # Parameters v0 = 20 # initial velocity (m/s) theta_deg = 45 theta_rad = np.radians(theta_deg) g = 9.81 # gravity (m/s\u00b2) # Time of flight T = 2 * v0 * np.sin(theta_rad) / g t = np.linspace(0, T, 100) # Vertical position y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 # Plot plt.figure(figsize=(8, 4)) plt.plot(t, y, color='blue', linewidth=2) plt.title(\"Vertical Motion: y(t) = v\u2080\u00b7sin(\u03b8)\u00b7t - \u00bd\u00b7g\u00b7t\u00b2\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Vertical Position y (m)\") plt.grid(True) plt.tight_layout() plt.savefig(\"vertical_motion_simple.png\") plt.show() The graph shows the vertical position of a projectile over time, forming a symmetric parabola due to gravity. Range Equation: The range \\( R \\) is the horizontal distance traveled during flight: \\[ R = v_{0x} T = v_0 \\cos \\theta \\cdot \\frac{2 v_0 \\sin \\theta}{g} \\] Using the identity \\( 2 \\sin \\theta \\cos \\theta = \\sin 2\\theta \\) , we obtain: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Show Python Code import matplotlib.pyplot as plt import numpy as np # Parameters v0 = 18 # example initial velocity (adjust if needed) g = 9.81 # gravity (m/s\u00b2) # Angle values from 0\u00b0 to 90\u00b0 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) # Range formula: R = (v0\u00b2 * sin(2\u03b8)) / g ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Use 45\u00b0 as the max point manually max_angle = 45 max_range = (v0**2 * np.sin(2 * np.radians(max_angle))) / g # Plot plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges, color='orange', label='Range') plt.title(\"Projectile Range vs Launch Angle\") plt.xlabel(\"Launch Angle (\u00b0)\") plt.ylabel(\"Range (m)\") plt.grid(True) plt.legend() # Annotate 45\u00b0 max point plt.plot(max_angle, max_range, 'ro') plt.text(max_angle, max_range + 2, f\"Max Range: {max_range:.2f} m\\nat {max_angle}\u00b0\", color='red', ha='center', fontsize=10) plt.xlim(0, 90) plt.ylim(0, max_range + 10) plt.tight_layout() plt.savefig(\"range_vs_angle.png\") plt.show() The graph shows how the projectile range changes with launch angle. Maximum range occurs at 45\u00b0, as predicted by the equation \\( R = \\frac{v_0^2 \\sin 2\\theta}{g} \\) . 3.2 Influence of Initial Conditions Initial Velocity \\( v_0 \\) : Increasing \\( v_0 \\) results in a larger range since \\( R \\propto v_0^2 \\) . Angle \\( \\theta \\) : The range is maximized at \\( \\theta = 45^\\circ \\) , as \\( \\sin 2\\theta \\) is maximized at this value. Gravitational Acceleration \\( g \\) : A higher \\( g \\) decreases the range since \\( R \\propto \\frac{1}{g} \\) . Show Python Code import numpy as np import matplotlib.pyplot as plt # Constants g_default = 9.81 theta_default_deg = 45 theta_default_rad = np.radians(theta_default_deg) v0_default = 20 # 1. Range vs Initial Velocity (v0) v0_values = np.linspace(5, 50, 200) range_vs_v0 = (v0_values**2 * np.sin(2 * theta_default_rad)) / g_default # 2. Range vs Launch Angle (\u03b8) theta_values_deg = np.linspace(0, 90, 200) theta_values_rad = np.radians(theta_values_deg) range_vs_theta = (v0_default**2 * np.sin(2 * theta_values_rad)) / g_default # 3. Range vs Gravity (g) g_values = np.linspace(1, 25, 200) range_vs_g = (v0_default**2 * np.sin(2 * theta_default_rad)) / g_values # Plot fig, axs = plt.subplots(1, 3, figsize=(18, 4)) axs[0].plot(v0_values, range_vs_v0, color='blue') axs[0].set_title(\"Effect of Initial Velocity $v_0$\") axs[0].set_xlabel(\"Initial Velocity $v_0$ (m/s)\") axs[0].set_ylabel(\"Range (m)\") axs[0].grid(True) axs[1].plot(theta_values_deg, range_vs_theta, color='orange', label='Range') axs[1].axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') axs[1].set_title(\"Effect of Launch Angle $\\\\theta$\") axs[1].set_xlabel(\"Launch Angle $\\\\theta$ (\u00b0)\") axs[1].set_ylabel(\"Range (m)\") axs[1].legend() axs[1].grid(True) axs[2].plot(g_values, range_vs_g, color='green') axs[2].set_title(\"Effect of Gravitational Acceleration $g$\") axs[2].set_xlabel(\"Gravity $g$ (m/s\u00b2)\") axs[2].set_ylabel(\"Range (m)\") axs[2].grid(True) plt.tight_layout() plt.savefig(\"influence_of_conditions.png\") plt.show() The plots illustrate how the projectile range is affected by initial velocity, launch angle, and gravitational acceleration: - Increasing \\( v_0 \\) leads to a quadratic increase in range. - The range is maximized at \\( \\theta = 45^\\circ \\) . - As gravity \\( g \\) increases, the range decreases inversely. 4. Analysis of the Range We simulate projectile motion for different angles and analyze how the range changes. Below is the Python implementation that computes and plots the range as a function of angle. Show Python Code import numpy as np import matplotlib.pyplot as plt def compute_range(v0, g=9.81): angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g return angles, ranges v0 = 20 # Initial velocity in m/s g = 9.81 # Gravity angles, ranges = compute_range(v0, g) plt.figure(figsize=(8,6)) plt.plot(angles, ranges, label=f'v0={v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.title(\"Range vs Angle of Projection\") plt.legend() plt.grid() plt.show() The range is maximized at 45\u00b0 for a constant initial speed of 20 m/s. Observations The range is maximum at \\( 45^\\circ \\) . Symmetry: The range for \\( \\theta \\) and \\( 90^\\circ - \\theta \\) is the same. Higher initial velocity shifts the curve upward, increasing the range. Show Python Code import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20 g = 9.81 angles = np.linspace(0, 90, 500) ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g # Complementary angles theta1 = 30 theta2 = 60 range1 = (v0**2 * np.sin(2 * np.radians(theta1))) / g range2 = (v0**2 * np.sin(2 * np.radians(theta2))) / g max_range = np.max(ranges) # Plot fig, ax = plt.subplots(figsize=(10, 6)) ax.plot(angles, ranges, color='orange', label='Range vs Angle') ax.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') # Title and labels plt.title(\"Range Symmetry for Complementary Angles\", fontsize=14, pad=40) ax.set_xlabel(\"Launch Angle (\u00b0)\") ax.set_ylabel(\"Range (m)\") # Symmetry text JUST below the title, inside the plot ax.text(45, ax.get_ylim()[1]*0.95, 'Symmetry', color='blue', ha='center', fontsize=12, weight='bold') # Complementary angle points ax.plot(theta1, range1, 'bo') ax.plot(theta2, range2, 'bo') ax.text(theta1, range1 + 2, '30\u00b0', color='blue', ha='center', fontsize=10) ax.text(theta2, range2 + 2, '60\u00b0', color='blue', ha='center', fontsize=10) # Final touches ax.legend() ax.grid(True) plt.tight_layout() plt.savefig(\"range_symmetry_clean.png\") plt.show() This graph illustrates the effect of launch angle on the projectile range. It clearly shows that the range is maximized at \\( 45^\\circ \\) , and that there is symmetry between complementary angles such as \\( 30^\\circ \\) and \\( 60^\\circ \\) , which result in the same range. 5. Practical Applications This model is used in various real-world scenarios: - Sports Science : Optimizing angles for long jumps, soccer kicks, or basketball shots. - Engineering : Missile and rocket trajectory predictions. - Astrophysics : Predicting planetary motion and interstellar object trajectories. Limitations and Extensions Air Resistance : Real-world projectiles experience drag, altering trajectories. Variable Gravity : In non-uniform gravitational fields, adjustments are required. Uneven Terrain : When launch and landing heights differ, new equations emerge. 6. Conclusion This study analyzed projectile range dependence on launch angle using fundamental physics principles and numerical simulations. The results align with theoretical predictions, showing that the range is maximized at \\( 45^\\circ \\) . The simplicity of the model makes it a valuable tool for understanding motion dynamics, though real-world factors such as air resistance and varying terrain must be considered for more accurate predictions.","title":"Problem1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem1","text":"","title":"Problem1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction","text":"Projectile motion is a fundamental concept in physics, describing the motion of an object launched into the air under the influence of gravity. This study explores how the range of a projectile depends on its angle of projection, analyzing the governing equations and simulating various scenarios to derive insights into its behavior. Understanding these principles has practical applications in fields such as sports, engineering, and aerospace","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-motivation","text":"Projectile motion is not only a fundamental topic in physics but also an essential component in real-world applications. From sports science to military engineering, the ability to predict and manipulate projectile trajectories is crucial. Analyzing the range as a function of the launch angle offers an intuitive yet mathematically rich problem that encapsulates both linear and quadratic relationships. Furthermore, varying initial conditions introduces a wide spectrum of solutions that enhance our understanding of motion in a gravitational field.","title":"2. Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-theoretical-foundation","text":"","title":"3. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-governing-equations","text":"The motion of a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) is governed by Newton\u2019s laws of motion. We decompose the velocity into horizontal and vertical components: \\[ v_{0x} = v_0 \\cos \\theta \\] \\[ v_{0y} = v_0 \\sin \\theta \\] The horizontal and vertical motions are analyzed separately: Horizontal Motion: \\[ x = v_{0x} t = v_0 \\cos \\theta \\cdot t \\] Since there is no acceleration in the horizontal direction (assuming no air resistance), motion remains uniform. Show Python Code import matplotlib.pyplot as plt import numpy as np # Initial parameters v0 = 20 # initial velocity (m/s) theta_deg = 45 # launch angle (degrees) theta_rad = np.radians(theta_deg) # Time array t = np.linspace(0, 3.2, 100) # Horizontal velocity component v0x = v0 * np.cos(theta_rad) # Horizontal position x = v0x * t # Plotting plt.figure(figsize=(8, 4)) plt.plot(t, x, color='orange', linewidth=2) plt.title(\"Horizontal Motion: x(t) = v\u2080\u00b7cos(\u03b8)\u00b7t\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Horizontal Position x (m)\") plt.grid(True) plt.tight_layout() plt.savefig(\"grafik_yatay.png\") plt.show() The graph shows the horizontal position increasing linearly over time, indicating constant velocity with no horizontal acceleration. Vertical Motion: The vertical motion is influenced by gravity \\( g \\) , with acceleration \\( -g \\) : \\[ y = v_{0y} t - \\frac{1}{2} g t^2 \\] The time of flight \\( T \\) can be determined by setting \\( y = 0 \\) (assuming launch and landing occur at the same height): \\[ T = \\frac{2 v_0 \\sin \\theta}{g} \\] Show Python Code import matplotlib.pyplot as plt import numpy as np # Parameters v0 = 20 # initial velocity (m/s) theta_deg = 45 theta_rad = np.radians(theta_deg) g = 9.81 # gravity (m/s\u00b2) # Time of flight T = 2 * v0 * np.sin(theta_rad) / g t = np.linspace(0, T, 100) # Vertical position y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 # Plot plt.figure(figsize=(8, 4)) plt.plot(t, y, color='blue', linewidth=2) plt.title(\"Vertical Motion: y(t) = v\u2080\u00b7sin(\u03b8)\u00b7t - \u00bd\u00b7g\u00b7t\u00b2\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Vertical Position y (m)\") plt.grid(True) plt.tight_layout() plt.savefig(\"vertical_motion_simple.png\") plt.show() The graph shows the vertical position of a projectile over time, forming a symmetric parabola due to gravity. Range Equation: The range \\( R \\) is the horizontal distance traveled during flight: \\[ R = v_{0x} T = v_0 \\cos \\theta \\cdot \\frac{2 v_0 \\sin \\theta}{g} \\] Using the identity \\( 2 \\sin \\theta \\cos \\theta = \\sin 2\\theta \\) , we obtain: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Show Python Code import matplotlib.pyplot as plt import numpy as np # Parameters v0 = 18 # example initial velocity (adjust if needed) g = 9.81 # gravity (m/s\u00b2) # Angle values from 0\u00b0 to 90\u00b0 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) # Range formula: R = (v0\u00b2 * sin(2\u03b8)) / g ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Use 45\u00b0 as the max point manually max_angle = 45 max_range = (v0**2 * np.sin(2 * np.radians(max_angle))) / g # Plot plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges, color='orange', label='Range') plt.title(\"Projectile Range vs Launch Angle\") plt.xlabel(\"Launch Angle (\u00b0)\") plt.ylabel(\"Range (m)\") plt.grid(True) plt.legend() # Annotate 45\u00b0 max point plt.plot(max_angle, max_range, 'ro') plt.text(max_angle, max_range + 2, f\"Max Range: {max_range:.2f} m\\nat {max_angle}\u00b0\", color='red', ha='center', fontsize=10) plt.xlim(0, 90) plt.ylim(0, max_range + 10) plt.tight_layout() plt.savefig(\"range_vs_angle.png\") plt.show() The graph shows how the projectile range changes with launch angle. Maximum range occurs at 45\u00b0, as predicted by the equation \\( R = \\frac{v_0^2 \\sin 2\\theta}{g} \\) .","title":"3.1 Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-influence-of-initial-conditions","text":"Initial Velocity \\( v_0 \\) : Increasing \\( v_0 \\) results in a larger range since \\( R \\propto v_0^2 \\) . Angle \\( \\theta \\) : The range is maximized at \\( \\theta = 45^\\circ \\) , as \\( \\sin 2\\theta \\) is maximized at this value. Gravitational Acceleration \\( g \\) : A higher \\( g \\) decreases the range since \\( R \\propto \\frac{1}{g} \\) . Show Python Code import numpy as np import matplotlib.pyplot as plt # Constants g_default = 9.81 theta_default_deg = 45 theta_default_rad = np.radians(theta_default_deg) v0_default = 20 # 1. Range vs Initial Velocity (v0) v0_values = np.linspace(5, 50, 200) range_vs_v0 = (v0_values**2 * np.sin(2 * theta_default_rad)) / g_default # 2. Range vs Launch Angle (\u03b8) theta_values_deg = np.linspace(0, 90, 200) theta_values_rad = np.radians(theta_values_deg) range_vs_theta = (v0_default**2 * np.sin(2 * theta_values_rad)) / g_default # 3. Range vs Gravity (g) g_values = np.linspace(1, 25, 200) range_vs_g = (v0_default**2 * np.sin(2 * theta_default_rad)) / g_values # Plot fig, axs = plt.subplots(1, 3, figsize=(18, 4)) axs[0].plot(v0_values, range_vs_v0, color='blue') axs[0].set_title(\"Effect of Initial Velocity $v_0$\") axs[0].set_xlabel(\"Initial Velocity $v_0$ (m/s)\") axs[0].set_ylabel(\"Range (m)\") axs[0].grid(True) axs[1].plot(theta_values_deg, range_vs_theta, color='orange', label='Range') axs[1].axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') axs[1].set_title(\"Effect of Launch Angle $\\\\theta$\") axs[1].set_xlabel(\"Launch Angle $\\\\theta$ (\u00b0)\") axs[1].set_ylabel(\"Range (m)\") axs[1].legend() axs[1].grid(True) axs[2].plot(g_values, range_vs_g, color='green') axs[2].set_title(\"Effect of Gravitational Acceleration $g$\") axs[2].set_xlabel(\"Gravity $g$ (m/s\u00b2)\") axs[2].set_ylabel(\"Range (m)\") axs[2].grid(True) plt.tight_layout() plt.savefig(\"influence_of_conditions.png\") plt.show() The plots illustrate how the projectile range is affected by initial velocity, launch angle, and gravitational acceleration: - Increasing \\( v_0 \\) leads to a quadratic increase in range. - The range is maximized at \\( \\theta = 45^\\circ \\) . - As gravity \\( g \\) increases, the range decreases inversely.","title":"3.2 Influence of Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-analysis-of-the-range","text":"We simulate projectile motion for different angles and analyze how the range changes. Below is the Python implementation that computes and plots the range as a function of angle. Show Python Code import numpy as np import matplotlib.pyplot as plt def compute_range(v0, g=9.81): angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g return angles, ranges v0 = 20 # Initial velocity in m/s g = 9.81 # Gravity angles, ranges = compute_range(v0, g) plt.figure(figsize=(8,6)) plt.plot(angles, ranges, label=f'v0={v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.title(\"Range vs Angle of Projection\") plt.legend() plt.grid() plt.show() The range is maximized at 45\u00b0 for a constant initial speed of 20 m/s.","title":"4. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"The range is maximum at \\( 45^\\circ \\) . Symmetry: The range for \\( \\theta \\) and \\( 90^\\circ - \\theta \\) is the same. Higher initial velocity shifts the curve upward, increasing the range. Show Python Code import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20 g = 9.81 angles = np.linspace(0, 90, 500) ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g # Complementary angles theta1 = 30 theta2 = 60 range1 = (v0**2 * np.sin(2 * np.radians(theta1))) / g range2 = (v0**2 * np.sin(2 * np.radians(theta2))) / g max_range = np.max(ranges) # Plot fig, ax = plt.subplots(figsize=(10, 6)) ax.plot(angles, ranges, color='orange', label='Range vs Angle') ax.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') # Title and labels plt.title(\"Range Symmetry for Complementary Angles\", fontsize=14, pad=40) ax.set_xlabel(\"Launch Angle (\u00b0)\") ax.set_ylabel(\"Range (m)\") # Symmetry text JUST below the title, inside the plot ax.text(45, ax.get_ylim()[1]*0.95, 'Symmetry', color='blue', ha='center', fontsize=12, weight='bold') # Complementary angle points ax.plot(theta1, range1, 'bo') ax.plot(theta2, range2, 'bo') ax.text(theta1, range1 + 2, '30\u00b0', color='blue', ha='center', fontsize=10) ax.text(theta2, range2 + 2, '60\u00b0', color='blue', ha='center', fontsize=10) # Final touches ax.legend() ax.grid(True) plt.tight_layout() plt.savefig(\"range_symmetry_clean.png\") plt.show() This graph illustrates the effect of launch angle on the projectile range. It clearly shows that the range is maximized at \\( 45^\\circ \\) , and that there is symmetry between complementary angles such as \\( 30^\\circ \\) and \\( 60^\\circ \\) , which result in the same range.","title":"Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-practical-applications","text":"This model is used in various real-world scenarios: - Sports Science : Optimizing angles for long jumps, soccer kicks, or basketball shots. - Engineering : Missile and rocket trajectory predictions. - Astrophysics : Predicting planetary motion and interstellar object trajectories.","title":"5. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"Air Resistance : Real-world projectiles experience drag, altering trajectories. Variable Gravity : In non-uniform gravitational fields, adjustments are required. Uneven Terrain : When launch and landing heights differ, new equations emerge.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-conclusion","text":"This study analyzed projectile range dependence on launch angle using fundamental physics principles and numerical simulations. The results align with theoretical predictions, showing that the range is maximized at \\( 45^\\circ \\) . The simplicity of the model makes it a valuable tool for understanding motion dynamics, though real-world factors such as air resistance and varying terrain must be considered for more accurate predictions.","title":"6. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Introduction and Motivation The forced damped pendulum exemplifies a rich dynamical system where nonlinear behavior arises from the interplay between gravitational restoring forces, frictional damping, and external periodic driving. This model is a foundation for understanding complex real-world phenomena such as resonance, synchronization, and chaos. By analyzing how variations in system parameters influence the behavior of the pendulum, we gain insights applicable to mechanical design, energy systems, and even biological rhythms. In this report, we explore the dynamics both theoretically and numerically, presenting detailed visualizations to highlight transitions between different regimes. 1. Theoretical Foundation 1.1 Governing Equation The motion of a forced damped pendulum is described by the second-order nonlinear differential equation: (d\u00b2\u03b8/dt\u00b2) + \u03b3\u00b7(d\u03b8/dt) + \u03c9\u2080\u00b2\u00b7sin(\u03b8) = A\u00b7cos(\u03c9\u00b7t) Where: ( \u03b8 ) is the angular displacement ( \u03b3 ) is the damping coefficient ( \u03c9\u2080 ) is the natural frequency (( \u03c9\u2080 = \u221a(g/L) )) ( A ) is the amplitude of the driving force ( \u03c9 ) is the driving frequence Free body diagram of a forced damped pendulum. The diagram illustrates all forces acting on the mass, including gravity (mg), damping (\u2212\u03b3\u03b8\u0307), external driving force (A\u00b7cos(\u03c9\u00b7t)), and tension along the string. Angular displacement \u03b8 and string length L are also indicated. Where: ( \u03b8 ) \u2192 Angular displacement ( \u03b3 ) \u2192 Damping coefficient ( \u03c9\u2080 ) \u2192 Natural frequency (( \u03c9\u2080 = \u221a(g / L) )) ( A ) \u2192 Amplitude of the driving force ( \u03c9 ) \u2192 Driving frequency 1.2 Small-Angle Approximation For small angular displacements, ( \\sin(\\theta) \\approx \\theta ), simplifying the equation to: (d\u00b2\u03b8/dt\u00b2) + \u03b3\u00b7(d\u03b8/dt) + \u03c9\u2080\u00b2\u00b7\u03b8 = A\u00b7cos(\u03c9\u00b7t) This graph shows the comparison between \\(\\theta\\) and \\(\\sin(\\theta)\\) for small angular displacements. For values of \\(\\theta\\) less than about 0.5 radians, both curves nearly overlap, demonstrating the validity of the small-angle approximation: \\(\\sin(\\theta) \\approx \\theta\\) . This is a linear non-homogeneous second-order ODE. The solution includes a transient and steady-state component, with the steady-state given by: \u03b8(t) = \u0398\u00b7cos(\u03c9\u00b7t \u2212 \u03b4) Where: ( \u0398 = A / \u221a((\u03c9\u2080\u00b2 \u2212 \u03c9\u00b2)\u00b2 + \u03b3\u00b2\u00b7\u03c9\u00b2) ) ( \u03b4 = tan\u207b\u00b9(\u03b3\u00b7\u03c9 / (\u03c9\u2080\u00b2 \u2212 \u03c9\u00b2)) ) 1.3 Resonance and Energy Transfer Resonance occurs when ( \u03c9 \u2248 \u03c9\u2080 ), leading to a peak in amplitude ( \u0398 ). At resonance, energy transfer from the driving force is maximized, which is critical in mechanical and electrical systems alike. As seen in the graph, the amplitude reaches its maximum near the natural frequency ( \u03c9\u2080 = 1.0 ), demonstrating resonance. At this point, the energy transfer from the driving force is most efficient. Increasing the damping coefficient ( \u03b3 ) would reduce and broaden the peak, making the system less responsive to resonance. This effect is critical in engineering applications where resonance can either be beneficial or dangerous. 2. Analysis of Dynamics 2.1 Influence of Parameters Damping Coefficient ( \u03b3 ) : Higher damping suppresses oscillations and reduces peak amplitude. It prevents resonance peaks from becoming unbounded. Driving Amplitude ( A ) : Larger amplitudes can push the system into non-linear and chaotic regimes. Driving Frequency ( \u03c9 ) : Controls resonance behavior; near-resonance leads to large oscillations, while mismatched frequencies result in minimal response. 2.2 Regular vs. Chaotic Behavior For large ( A ) and intermediate ( \u03b3 ), the pendulum may exhibit chaotic behavior. This is marked by sensitive dependence on initial conditions and aperiodic trajectories. We distinguish: Periodic motion : Regular oscillations with fixed frequency. Quasiperiodic motion : Multiple incommensurate frequencies. Chaotic motion : Non-repeating, sensitive to initial conditions. Figure: Time series of \u03b8(t) for three different dynamical regimes. The left panel shows periodic motion, the middle one shows quasiperiodic behavior, and the right panel shows chaotic dynamics. 3. Practical Applications Suspension Bridges : External periodic forces (e.g., wind or traffic) can drive resonant vibrations, necessitating damping mechanisms. Energy Harvesters : Systems that exploit resonance to convert oscillatory energy into usable electrical power. Oscillating Circuits : Analogous to driven RLC circuits where voltage plays the role of angular displacement. Biomechanics : Walking and running patterns often resemble driven pendula. 4. Computational Implementation 4.1 Simulation Code A Python simulation using the 4th-order Runge-Kutta method is implemented to numerically solve the system. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # System parameters gamma = 0.2 A = 1.2 omega = 2/3 omega0 = 1.0 # Time span and initial conditions t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) y0 = [0.1, 0] # Initial angle and angular velocity # Forced damped pendulum ODE def pendulum(t, y): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -gamma * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Solve ODE sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum - Angular Displacement vs Time\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.grid(True) plt.show() 4.2 Visualizations Key visualizations include: Time evolution : ( \u03b8(t) ) Phase portraits : ( \u03b8 ) vs ( \u1e8b ) (or ( \\dot{\u03b8} \\ )) Poincar\u00e9 sections : Sampling the system at intervals of ( 2\u03c0 / \u03c9 ) Bifurcation diagrams : Mapping final state as a function of ( A ) or ( \u03c9 ) This visualization shows the relationship between \u03b8 (angular displacement) and \u1e8b (angular velocity). This visualization samples the system at regular intervals to analyze its chaotic behavior. 4.3 Phase Diagrams & Poincar\u00e9 Sections These visual tools highlight the system's transition from order to chaos. # Phase diagram plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1], lw=0.5) plt.title(\"Phase Portrait\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.grid(True) plt.show() # Poincar\u00e9 section period = 2 * np.pi / omega poincare_times = np.arange(0, t_span[1], period) indices = [np.argmin(np.abs(sol.t - pt)) for pt in poincare_times] plt.figure(figsize=(6, 6)) plt.plot(sol.y[0][indices], sol.y[1][indices], 'o', markersize=2) plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.grid(True) plt.show() 5. Limitations and Extensions Limitations Small-angle approximation fails for large angles. This graph compares the small-angle approximation (sin(\u03b8) \u2248 \u03b8) with the actual sine function (sin(\u03b8)) for larger angles. The orange dashed line represents the small-angle approximation, which is valid only for small angles, while the blue line represents the true sin(\u03b8) function. The discrepancy becomes more apparent as the angle increases beyond approximately 0.5 radians. Linear damping may not capture real-world friction. This graph compares linear damping (\u03b3 \u00b7 \u03b8\u0307) with real-world friction, which is typically nonlinear and proportional to the square of velocity (v\u00b2). The blue line represents linear damping, while the red line shows nonlinear friction. The graph illustrates how real-world friction increases more rapidly with velocity than linear damping. Harmonic driving oversimplifies non-periodic influences. This graph compares harmonic driving force (cos(\u03c9 t)) with non-periodic driving forces, represented by random noise. The green line represents the periodic, harmonic force, while the orange line represents the non-periodic, random driving force. The graph highlights the difference between regular oscillations and irregular, random inputs in forced systems. Extensions Nonlinear damping : e.g., quadratic velocity terms. This graph shows the difference between linear damping (orange line) and nonlinear damping (blue dashed line). Nonlinear damping increases rapidly, while linear damping grows linearly with angular velocity (\u03c9). Stochastic forcing : To simulate random environmental inputs. This graph compares harmonic driving force (light blue line) with non-periodic driving force (orange line). The harmonic force follows a regular oscillatory pattern, while the non-periodic force introduces irregular fluctuations, simulating random environmental inputs. Coupled pendula : Network behavior and synchronization. This graph shows the synchronized motion of two coupled pendula. The blue line represents Pendulum 1 (\u03b8\u2081), while the red line represents Pendulum 2 (\u03b8\u2082). Both pendulums exhibit synchronized oscillations, highlighting the concept of synchronization and network behavior in coupled systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#introduction-and-motivation","text":"The forced damped pendulum exemplifies a rich dynamical system where nonlinear behavior arises from the interplay between gravitational restoring forces, frictional damping, and external periodic driving. This model is a foundation for understanding complex real-world phenomena such as resonance, synchronization, and chaos. By analyzing how variations in system parameters influence the behavior of the pendulum, we gain insights applicable to mechanical design, energy systems, and even biological rhythms. In this report, we explore the dynamics both theoretically and numerically, presenting detailed visualizations to highlight transitions between different regimes.","title":"Introduction and Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-governing-equation","text":"The motion of a forced damped pendulum is described by the second-order nonlinear differential equation: (d\u00b2\u03b8/dt\u00b2) + \u03b3\u00b7(d\u03b8/dt) + \u03c9\u2080\u00b2\u00b7sin(\u03b8) = A\u00b7cos(\u03c9\u00b7t) Where: ( \u03b8 ) is the angular displacement ( \u03b3 ) is the damping coefficient ( \u03c9\u2080 ) is the natural frequency (( \u03c9\u2080 = \u221a(g/L) )) ( A ) is the amplitude of the driving force ( \u03c9 ) is the driving frequence Free body diagram of a forced damped pendulum. The diagram illustrates all forces acting on the mass, including gravity (mg), damping (\u2212\u03b3\u03b8\u0307), external driving force (A\u00b7cos(\u03c9\u00b7t)), and tension along the string. Angular displacement \u03b8 and string length L are also indicated.","title":"1.1 Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#where","text":"( \u03b8 ) \u2192 Angular displacement ( \u03b3 ) \u2192 Damping coefficient ( \u03c9\u2080 ) \u2192 Natural frequency (( \u03c9\u2080 = \u221a(g / L) )) ( A ) \u2192 Amplitude of the driving force ( \u03c9 ) \u2192 Driving frequency","title":"Where:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-small-angle-approximation","text":"For small angular displacements, ( \\sin(\\theta) \\approx \\theta ), simplifying the equation to: (d\u00b2\u03b8/dt\u00b2) + \u03b3\u00b7(d\u03b8/dt) + \u03c9\u2080\u00b2\u00b7\u03b8 = A\u00b7cos(\u03c9\u00b7t) This graph shows the comparison between \\(\\theta\\) and \\(\\sin(\\theta)\\) for small angular displacements. For values of \\(\\theta\\) less than about 0.5 radians, both curves nearly overlap, demonstrating the validity of the small-angle approximation: \\(\\sin(\\theta) \\approx \\theta\\) . This is a linear non-homogeneous second-order ODE. The solution includes a transient and steady-state component, with the steady-state given by: \u03b8(t) = \u0398\u00b7cos(\u03c9\u00b7t \u2212 \u03b4) Where: ( \u0398 = A / \u221a((\u03c9\u2080\u00b2 \u2212 \u03c9\u00b2)\u00b2 + \u03b3\u00b2\u00b7\u03c9\u00b2) ) ( \u03b4 = tan\u207b\u00b9(\u03b3\u00b7\u03c9 / (\u03c9\u2080\u00b2 \u2212 \u03c9\u00b2)) )","title":"1.2 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-resonance-and-energy-transfer","text":"Resonance occurs when ( \u03c9 \u2248 \u03c9\u2080 ), leading to a peak in amplitude ( \u0398 ). At resonance, energy transfer from the driving force is maximized, which is critical in mechanical and electrical systems alike. As seen in the graph, the amplitude reaches its maximum near the natural frequency ( \u03c9\u2080 = 1.0 ), demonstrating resonance. At this point, the energy transfer from the driving force is most efficient. Increasing the damping coefficient ( \u03b3 ) would reduce and broaden the peak, making the system less responsive to resonance. This effect is critical in engineering applications where resonance can either be beneficial or dangerous.","title":"1.3 Resonance and Energy Transfer"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-influence-of-parameters","text":"Damping Coefficient ( \u03b3 ) : Higher damping suppresses oscillations and reduces peak amplitude. It prevents resonance peaks from becoming unbounded. Driving Amplitude ( A ) : Larger amplitudes can push the system into non-linear and chaotic regimes. Driving Frequency ( \u03c9 ) : Controls resonance behavior; near-resonance leads to large oscillations, while mismatched frequencies result in minimal response.","title":"2.1 Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-regular-vs-chaotic-behavior","text":"For large ( A ) and intermediate ( \u03b3 ), the pendulum may exhibit chaotic behavior. This is marked by sensitive dependence on initial conditions and aperiodic trajectories. We distinguish: Periodic motion : Regular oscillations with fixed frequency. Quasiperiodic motion : Multiple incommensurate frequencies. Chaotic motion : Non-repeating, sensitive to initial conditions. Figure: Time series of \u03b8(t) for three different dynamical regimes. The left panel shows periodic motion, the middle one shows quasiperiodic behavior, and the right panel shows chaotic dynamics.","title":"2.2 Regular vs. Chaotic Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Suspension Bridges : External periodic forces (e.g., wind or traffic) can drive resonant vibrations, necessitating damping mechanisms. Energy Harvesters : Systems that exploit resonance to convert oscillatory energy into usable electrical power. Oscillating Circuits : Analogous to driven RLC circuits where voltage plays the role of angular displacement. Biomechanics : Walking and running patterns often resemble driven pendula.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-computational-implementation","text":"","title":"4. Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-simulation-code","text":"A Python simulation using the 4th-order Runge-Kutta method is implemented to numerically solve the system. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # System parameters gamma = 0.2 A = 1.2 omega = 2/3 omega0 = 1.0 # Time span and initial conditions t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) y0 = [0.1, 0] # Initial angle and angular velocity # Forced damped pendulum ODE def pendulum(t, y): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -gamma * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Solve ODE sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum - Angular Displacement vs Time\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.grid(True) plt.show()","title":"4.1 Simulation Code"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-visualizations","text":"Key visualizations include: Time evolution : ( \u03b8(t) ) Phase portraits : ( \u03b8 ) vs ( \u1e8b ) (or ( \\dot{\u03b8} \\ )) Poincar\u00e9 sections : Sampling the system at intervals of ( 2\u03c0 / \u03c9 ) Bifurcation diagrams : Mapping final state as a function of ( A ) or ( \u03c9 ) This visualization shows the relationship between \u03b8 (angular displacement) and \u1e8b (angular velocity). This visualization samples the system at regular intervals to analyze its chaotic behavior.","title":"4.2 Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#43-phase-diagrams-poincare-sections","text":"These visual tools highlight the system's transition from order to chaos. # Phase diagram plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1], lw=0.5) plt.title(\"Phase Portrait\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.grid(True) plt.show() # Poincar\u00e9 section period = 2 * np.pi / omega poincare_times = np.arange(0, t_span[1], period) indices = [np.argmin(np.abs(sol.t - pt)) for pt in poincare_times] plt.figure(figsize=(6, 6)) plt.plot(sol.y[0][indices], sol.y[1][indices], 'o', markersize=2) plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.grid(True) plt.show()","title":"4.3 Phase Diagrams &amp; Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-extensions","text":"","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"Small-angle approximation fails for large angles. This graph compares the small-angle approximation (sin(\u03b8) \u2248 \u03b8) with the actual sine function (sin(\u03b8)) for larger angles. The orange dashed line represents the small-angle approximation, which is valid only for small angles, while the blue line represents the true sin(\u03b8) function. The discrepancy becomes more apparent as the angle increases beyond approximately 0.5 radians. Linear damping may not capture real-world friction. This graph compares linear damping (\u03b3 \u00b7 \u03b8\u0307) with real-world friction, which is typically nonlinear and proportional to the square of velocity (v\u00b2). The blue line represents linear damping, while the red line shows nonlinear friction. The graph illustrates how real-world friction increases more rapidly with velocity than linear damping. Harmonic driving oversimplifies non-periodic influences. This graph compares harmonic driving force (cos(\u03c9 t)) with non-periodic driving forces, represented by random noise. The green line represents the periodic, harmonic force, while the orange line represents the non-periodic, random driving force. The graph highlights the difference between regular oscillations and irregular, random inputs in forced systems.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extensions","text":"Nonlinear damping : e.g., quadratic velocity terms. This graph shows the difference between linear damping (orange line) and nonlinear damping (blue dashed line). Nonlinear damping increases rapidly, while linear damping grows linearly with angular velocity (\u03c9). Stochastic forcing : To simulate random environmental inputs. This graph compares harmonic driving force (light blue line) with non-periodic driving force (orange line). The harmonic force follows a regular oscillatory pattern, while the non-periodic force introduces irregular fluctuations, simulating random environmental inputs. Coupled pendula : Network behavior and synchronization. This graph shows the synchronized motion of two coupled pendula. The blue line represents Pendulum 1 (\u03b8\u2081), while the red line represents Pendulum 2 (\u03b8\u2082). Both pendulums exhibit synchronized oscillations, highlighting the concept of synchronization and network behavior in coupled systems.","title":"Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}